//--------------------------------------------------------------------------------------------------
// Definitions
//--------------------------------------------------------------------------------------------------

#pragma kernel VolumetricLightingAllLights VolumetricLighting=VolumetricLightingAllLights LIGHTLOOP_SINGLE_PASS
#pragma kernel VolumetricLightingClustered VolumetricLighting=VolumetricLightingClustered LIGHTLOOP_TILE_PASS   USE_CLUSTERED_LIGHTLIST

#pragma enable_d3d11_debug_symbols

#include "../../../ShaderPass/ShaderPass.cs.hlsl"
#define SHADERPASS    SHADERPASS_VOLUMETRIC_LIGHTING
#define GROUP_SIZE_1D 16
#define GROUP_SIZE_2D (GROUP_SIZE_1D * GROUP_SIZE_1D)
// #define USE_HENYEY_GREENSTEIN_PHASE_FUNCTION

//--------------------------------------------------------------------------------------------------
// Included headers
//--------------------------------------------------------------------------------------------------

#include "../../../../Core/ShaderLibrary/Common.hlsl"
#include "../../../../Core/ShaderLibrary/SpaceFillingCurves.hlsl"
#include "../../../../Core/ShaderLibrary/VolumeRendering.hlsl"

#include "../VolumetricLighting.cs.hlsl"
#define UNITY_MATERIAL_LIT // Need to be defined before including Material.hlsl
#include "../../../ShaderVariables.hlsl"
#include "../../../Lighting/Lighting.hlsl" // This includes Material.hlsl

//--------------------------------------------------------------------------------------------------
// Inputs & outputs
//--------------------------------------------------------------------------------------------------

RW_TEXTURE3D(float4, _VolumetricLightingBufferCurrentFrame); // RGB = radiance, A = optical depth
TEXTURE3D(_VolumetricLightingBufferAccumulation);            // RGB = radiance, A = optical depth

CBUFFER_START(UnityVolumetricLighting)
    float4x4 _vBufferCoordToViewDirWS; // Actually just 3x3, but Unity can only set 4x4
CBUFFER_END

//--------------------------------------------------------------------------------------------------
// Implementation
//--------------------------------------------------------------------------------------------------

struct Ray
{
    float3 originWS;
    float3 directionWS; // Normalized
    float  ratioLenToZ; // Ratio of view space length to view space Z
};

// Computes the in-scattered radiance along the ray.
void FillVolumetricLightingBuffer(Ray cameraRay, float4 depthParams, uint2 tileCoord, uint2 voxelCoord, uint sliceCount = 64)
{
    float3 scattering = _GlobalFog_Scattering;
    float  extinction = _GlobalFog_Extinction;
#ifdef USE_HENYEY_GREENSTEIN_PHASE_FUNCTION
    float  asymmetry  = _GlobalFog_Asymmetry;
#endif

    LightLoopContext context;
    // ZERO_INITIALIZE(LightLoopContext, context);
    context.shadowContext = InitShadowContext();
    uint featureFlags = 0xFFFFFFFF;       // TODO

    float n  = depthParams.x;             // View space Z coordinate of the near plane
    float t0 = n * cameraRay.ratioLenToZ; // Distance to the near plane
    float du = rcp(sliceCount);           // Log-encoded distance between slices

    float3 totalRadiance = 0;
    float  opticalDepth  = 0;

    for (uint s = 0; s < sliceCount; s++)
    {
        float u1 = s * du + du; // (s + 1) / sliceCount
        float t1 = DecodeLogarithmicDepth(u1, depthParams) * cameraRay.ratioLenToZ;
        float dt = t1 - t0;

        // Integral{a, b}{Transmittance(0, x) dx} = Transmittance(0, a) * Integral{0, b - a}{Transmittance(a, a + x) dx}.
        float transmittance = Transmittance(opticalDepth) * TransmittanceIntegralHomogeneous(extinction, dt);

        // TODO: low-discrepancy point set, mirroring around the bounds of the camera frustum.
        // Note: using 0.5 here (in the linear space) does not guarantee that we stay within the bounds!
        float t = t0 + 0.5 * dt;

        float3 positionWS = cameraRay.originWS + t * cameraRay.directionWS;

        float3 sampleRadiance = 0;

        if (featureFlags & LIGHTFEATUREFLAGS_DIRECTIONAL)
        {
            for (uint i = 0; i < _DirectionalLightCount; ++i)
            {
                // Fetch the light.
                DirectionalLightData lightData = _DirectionalLightDatas[i];

                float3 L         = -lightData.forward; // Lights point backwards in Unity
                float  intensity = 1;
                float3 color     = lightData.color;

            #ifdef USE_HENYEY_GREENSTEIN_PHASE_FUNCTION
                // Note: we apply the scattering coefficient and the constant part of the phase function later.
                intensity *= HenyeyGreensteinPhasePartVarying(asymmetry, dot(L, cameraRay.directionWS));
            #endif

                [branch] if (lightData.shadowIndex >= 0)
                {
                    float shadow = GetDirectionalShadowAttenuation(context.shadowContext, positionWS,
                                   0, lightData.shadowIndex, L);

                    intensity *= shadow;
                }

                [branch] if (lightData.cookieIndex >= 0)
                {
                    float3 lightToSample = positionWS - lightData.positionWS;
                    float4 cookie = EvaluateCookie_Directional(context, lightData, lightToSample);

                    color     *= cookie.rgb;
                    intensity *= cookie.a;
                }

                // Compute the amount of in-scattered radiance.
                sampleRadiance += color * intensity;
            }
        }

        if (featureFlags & LIGHTFEATUREFLAGS_PUNCTUAL)
        {
            uint punctualLightCount;

        #ifdef LIGHTLOOP_TILE_PASS
            PositionInputs posInput;
            posInput.depthVS = t;
            posInput.unTileCoord = tileCoord;

            uint punctualLightStart;
            GetCountAndStart(posInput, LIGHTCATEGORY_PUNCTUAL, punctualLightStart, punctualLightCount);
        #else
            punctualLightCount = _PunctualLightCount;
        #endif

            for (uint i = 0; i < punctualLightCount; ++i)
            {
            #ifdef LIGHTLOOP_TILE_PASS
                uint punctualLightIndex = FetchIndex(punctualLightStart, i);
            #else
                uint punctualLightIndex = i;
            #endif

                // Fetch the light.
                LightData lightData  = _LightDatas[punctualLightIndex];
                int       lightType  = lightData.lightType;

                float3 lightToSample = positionWS - lightData.positionWS;
                float  distSq        = dot(lightToSample, lightToSample);
                float  dist          = sqrt(distSq);
                float3 L             = lightToSample * -rsqrt(distSq);
                float  clampedDistSq = max(distSq, 0.25); // Reduce undersampling
                float  intensity     = GetPunctualShapeAttenuation(lightData, L, clampedDistSq);
                float3 color         = lightData.color;

            #ifdef USE_HENYEY_GREENSTEIN_PHASE_FUNCTION
                // Note: we apply the scattering coefficient and the constant part of the phase function later.
                intensity *= HenyeyGreensteinPhasePartVarying(asymmetry, dot(L, cameraRay.directionWS));
            #endif
                intensity *= Transmittance(OpticalDepthHomogeneous(extinction, dist));

                [branch] if (lightData.shadowIndex >= 0)
                {
                    // TODO: make projector lights cast shadows.
                    float3 offset = 0; // GetShadowPosOffset(nDotL, normal);

                    float shadow = GetPunctualShadowAttenuation(context.shadowContext, positionWS + offset,
                                   0, lightData.shadowIndex, float4(L, dist));

                    intensity *= lerp(1, shadow, lightData.shadowDimmer);
                }

                // Projector lights always have a cookies, so we can perform clipping inside the if().
                [branch] if (lightData.cookieIndex >= 0)
                {
                    float4 cookie = EvaluateCookie_Punctual(context, lightData, lightToSample);

                    color     *= cookie.rgb;
                    intensity *= cookie.a;
                }

                // Compute the amount of in-scattered radiance.
                sampleRadiance += color * intensity;
            }
        }

    #ifdef USE_HENYEY_GREENSTEIN_PHASE_FUNCTION
        float3 phaseConstant = scattering * HenyeyGreensteinPhasePartConstant(asymmetry);
    #else
        float3 phaseConstant = scattering * IsotropicPhaseFunction();
    #endif

        // Compute optical depth up to the center of the interval.
        opticalDepth  += extinction * (0.5 * dt);
        totalRadiance += transmittance * phaseConstant * sampleRadiance;

        // Store the voxel data. TODO: reprojection using camera motion vectors.
        _VolumetricLightingBufferCurrentFrame[uint3(voxelCoord, s)] = float4(totalRadiance, opticalDepth);

        // Compute optical depth up to the end of the interval.
        opticalDepth += extinction * (0.5 * dt);

        t0 = t1;
    }
}

int GetLog2NumVoxelsPerLightTile()
{
    // Assume that the light tile size is an base-2 multiple of the voxel tile size.
    return (int)log2(GetTileSize()) - (int)_vBufferResolution.w;
}

[numthreads(GROUP_SIZE_2D, 1, 1)]
void VolumetricLighting(uint2 groupId       : SV_GroupID,
                        uint  groupThreadId : SV_GroupThreadID)
{
    // Note: any factor of 64 is a suitable wave size for our algorithm.
    uint waveIndex = groupThreadId / 64;
    uint laneIndex = groupThreadId % 64;
    uint quadIndex = laneIndex / 4;

    // Arrange threads in the Morton order to optimally match the memory layout of GCN tiles.
    uint  mortonCode = groupThreadId;
    uint2 localCoord = DecodeMorton2D(mortonCode);
    uint2 tileAnchor = groupId * GROUP_SIZE_1D;
    uint2 voxelCoord = tileAnchor + localCoord;
    uint2 tileCoord  = tileAnchor >> GetLog2NumVoxelsPerLightTile();

    [branch] if (voxelCoord.x >= (uint)_vBufferResolution.x ||
                 voxelCoord.y >= (uint)_vBufferResolution.y)
    {
        return;
    }

    // TODO: read the HiZ texture in order to skip evaluation of lighting in occluded voxels.
#ifdef UNITY_REVERSED_Z
    // float tileMaxZ = ...
#else
    // float tileMaxZ = ...
#endif
    // Determine the farthest unoccluded voxel...

    // TODO: low-discrepancy point set, mirroring around the bounds of the camera frustum.
    float2 sampleCoord = voxelCoord + 0.5;

    // Compute the unnormalized ray direction s.t. its Z coordinate in the view space is equal to 1.
    float3 dir = -mul(float3(sampleCoord, 1), (float3x3)_vBufferCoordToViewDirWS);

    // Compute the ratio of the length of the vector to its view space Z coordinate.
    float  len = length(dir);

    Ray cameraRay;
    cameraRay.originWS    = GetCurrentViewPosition();
    cameraRay.directionWS = normalize(dir);
    cameraRay.ratioLenToZ = len;

    FillVolumetricLightingBuffer(cameraRay, _vBufferDepthEncodingParams, tileCoord, voxelCoord);
}
